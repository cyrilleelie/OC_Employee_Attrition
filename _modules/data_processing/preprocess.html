

<!DOCTYPE html>
<html class="writer-html5" lang="fr" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>data_processing.preprocess &mdash; Documentation Attrition RH API v0.2.1</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=44cc1bf8"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/translations.js?v=e6b791cb"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Recherche" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Attrition RH API
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Rechercher docs" aria-label="Rechercher docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contenu:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation_guide.html">Guide d’Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../model_documentation.html">Documentation Technique du Modèle de Prédiction d’Attrition RH</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_usage_examples.html">Exemples d’Utilisation de l’API de Prédiction d’Attrition RH</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Guide de Contribution au Projet d’Attrition RH</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Attrition RH API</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Code du module</a></li>
      <li class="breadcrumb-item active">data_processing.preprocess</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Code source de data_processing.preprocess</h1><div class="highlight"><pre>
<span></span><span class="c1"># Dans src/data_processing/preprocess.py</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module de prétraitement des données pour le projet d&#39;attrition RH.</span>

<span class="sd">Ce module contient les fonctions nécessaires pour :</span>

<span class="sd">* Mapper les features binaires.</span>
<span class="sd">* Nettoyer les données brutes (conversion de la cible, suppression de colonnes, gestion des doublons, conversion de types spécifiques comme les pourcentages).</span>
<span class="sd">* Créer de nouvelles features (feature engineering) - actuellement un placeholder.</span>
<span class="sd">* Construire une pipeline de prétraitement Scikit-learn (ColumnTransformer) pour l&#39;imputation, la mise à l&#39;échelle des numériques, et l&#39;encodage des catégorielles (OneHot et Ordinal).</span>
<span class="sd">* Exécuter l&#39;ensemble de ce pipeline de preprocessing.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">StandardScaler</span><span class="p">,</span> <span class="n">OneHotEncoder</span><span class="p">,</span> <span class="n">OrdinalEncoder</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.compose</span><span class="w"> </span><span class="kn">import</span> <span class="n">ColumnTransformer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.impute</span><span class="w"> </span><span class="kn">import</span> <span class="n">SimpleImputer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">config</span><span class="p">,</span>
<span class="p">)</span>  <span class="c1"># Pour config.TARGET_VARIABLE, config.BINARY_FEATURES_MAPPING, etc.</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>  <span class="c1"># Pour np.number lors de la sélection de dtypes</span>

<span class="c1"># Configuration du logging pour ce module</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(asctime)s</span><span class="s2"> - </span><span class="si">%(name)s</span><span class="s2"> - </span><span class="si">%(levelname)s</span><span class="s2"> - </span><span class="si">%(message)s</span><span class="s2">&quot;</span>
<span class="p">)</span>
<div class="viewcode-block" id="logger">
<a class="viewcode-back" href="../../autoapi/data_processing/preprocess/index.html#data_processing.preprocess.logger">[docs]</a>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span></div>



<div class="viewcode-block" id="map_binary_features">
<a class="viewcode-back" href="../../autoapi/data_processing/preprocess/index.html#data_processing.preprocess.map_binary_features">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_binary_features</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">binary_cols_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mappe les valeurs des colonnes catégorielles binaires spécifiées en 0 et 1.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): DataFrame d&#39;entrée.</span>
<span class="sd">        binary_cols_map (dict): Dictionnaire où les clés sont les noms de colonnes</span>
<span class="sd">                                et les valeurs sont des dictionnaires de mapping</span>
<span class="sd">                                (ex: {&#39;Oui&#39;: 1, &#39;Non&#39;: 0}).</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: DataFrame avec les colonnes binaires mappées.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># Évite les SettingWithCopyWarning</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Application du mappage sur les features binaires...&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="n">binary_cols_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># Assurer que la colonne est de type string avant d&#39;appliquer .map</span>
            <span class="c1"># Cela évite des erreurs si une colonne est déjà numérique (ex: 0/1)</span>
            <span class="c1"># ou contient des types mixtes.</span>
            <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
            <span class="c1"># Après .map, les valeurs non trouvées dans le mapping deviennent NaN.</span>
            <span class="c1"># Il est important que ces NaN soient de type float pour que SimpleImputer (numérique) fonctionne.</span>
            <span class="c1"># Si la colonne originale était object et contenait des strings et des NaN après map,</span>
            <span class="c1"># SimpleImputer(strategy=&#39;most_frequent&#39;) fonctionnerait mais SimpleImputer(strategy=&#39;median&#39;) échouerait.</span>
            <span class="c1"># Le plus sûr est de convertir en type numérique si on s&#39;attend à 0 et 1.</span>
            <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span>
                <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span>
            <span class="p">)</span>  <span class="c1"># Convertit en float, les erreurs (anciens NaN) restent NaN</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Colonne &#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#39; mappée en binaire numérique.&quot;</span><span class="p">)</span>

            <span class="n">nan_count</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">nan_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nan_count</span><span class="si">}</span><span class="s2"> valeur(s) dans la colonne &#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#39; n&#39;ont pas pu être mappée(s) &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;correctement et sont devenue(s) NaN (ou étaient déjà NaN).&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Colonne binaire &#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#39; spécifiée pour mappage mais non trouvée dans le DataFrame.&quot;</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>



<div class="viewcode-block" id="clean_data">
<a class="viewcode-back" href="../../autoapi/data_processing/preprocess/index.html#data_processing.preprocess.clean_data">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">clean_data</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applique les étapes de nettoyage de base et les conversions de types spécifiques.</span>

<span class="sd">    - Convertit la variable cible textuelle en format numérique.</span>
<span class="sd">    - Supprime les colonnes jugées inutiles ou redondantes.</span>
<span class="sd">    - Supprime les lignes dupliquées.</span>
<span class="sd">    - Convertit la colonne &#39;augementation_salaire_precedente&#39; (texte en &quot;XX %&quot;) en numérique.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): DataFrame d&#39;entrée brut ou fusionné.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: DataFrame nettoyé.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Si la colonne cible &#39;a_quitte_l_entreprise&#39; est manquante.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Début du nettoyage des données...&quot;</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Conversion de la variable cible</span>
    <span class="k">if</span> <span class="s2">&quot;a_quitte_l_entreprise&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">config</span><span class="o">.</span><span class="n">TARGET_VARIABLE</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;a_quitte_l_entreprise&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;Oui&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Non&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="c1"># Convertir en type entier nullable pour gérer les NaN si map échoue pour certaines valeurs</span>
        <span class="n">df</span><span class="p">[</span><span class="n">config</span><span class="o">.</span><span class="n">TARGET_VARIABLE</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="n">config</span><span class="o">.</span><span class="n">TARGET_VARIABLE</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;Int64&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Colonne cible &#39;</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">TARGET_VARIABLE</span><span class="si">}</span><span class="s2">&#39; créée et convertie en Int64.&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Pour la prédiction, cette colonne ne sera pas présente.</span>
        <span class="c1"># On ne devrait pas lever d&#39;erreur si on est en mode prédiction.</span>
        <span class="c1"># Cette fonction est appelée par run_preprocessing_pipeline qui sépare X et y *après*.</span>
        <span class="c1"># Et aussi par populate_db qui a besoin de la cible.</span>
        <span class="c1"># Pour predict.py, on ajoute une colonne factice &#39;a_quitte_l_entreprise&#39;.</span>
        <span class="c1"># Donc, cette condition est surtout pour la robustesse lors de l&#39;entraînement.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;La colonne &#39;a_quitte_l_entreprise&#39; est manquante. Si c&#39;est pour la prédiction, c&#39;est normal.&quot;</span>
        <span class="p">)</span>
        <span class="c1"># Si cette fonction est appelée par un flux où la cible DOIT être là (comme populate_db ou train_model avant split X/y)</span>
        <span class="c1"># alors une erreur est appropriée.</span>
        <span class="c1"># Pour l&#39;instant, on logue un warning, le check de présence de TARGET_VARIABLE se fera plus tard.</span>

    <span class="c1"># Liste des colonnes à supprimer (adaptez si nécessaire)</span>
    <span class="c1"># &#39;id_employee&#39; est conservé pour le moment, car il est utilisé par populate_db</span>
    <span class="c1"># et sera explicitement retiré de X dans train_model.py avant l&#39;entraînement.</span>
    <span class="n">cols_to_drop</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;nombre_heures_travailless&quot;</span><span class="p">,</span>  <span class="c1"># Semble être une coquille (s en trop)</span>
        <span class="s2">&quot;eval_number&quot;</span><span class="p">,</span>
        <span class="s2">&quot;nombre_employee_sous_responsabilite&quot;</span><span class="p">,</span>
        <span class="s2">&quot;code_sondage&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ayant_enfants&quot;</span><span class="p">,</span>
        <span class="s2">&quot;a_quitte_l_entreprise&quot;</span><span class="p">,</span>  <span class="c1"># Version texte de la cible, une fois la version numérique créée</span>
        <span class="s2">&quot;annee_experience_totale&quot;</span><span class="p">,</span>  <span class="c1"># Supposée redondante ou moins pertinente</span>
        <span class="s2">&quot;niveau_hierarchique_poste&quot;</span><span class="p">,</span>  <span class="c1"># Supposée redondante ou moins pertinente</span>
        <span class="s2">&quot;annees_dans_le_poste_actuel&quot;</span><span class="p">,</span>  <span class="c1"># Supposée redondante ou moins pertinente</span>
        <span class="s2">&quot;annes_sous_responsable_actuel&quot;</span><span class="p">,</span>  <span class="c1"># Coquille &quot;annes&quot; -&gt; &quot;annees&quot; ?</span>
    <span class="p">]</span>
    <span class="n">actual_cols_to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols_to_drop</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">actual_cols_to_drop</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">actual_cols_to_drop</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Colonnes supprimées : </span><span class="si">{</span><span class="n">actual_cols_to_drop</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Aucune colonne de la liste `cols_to_drop` n&#39;a été trouvée pour suppression.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Suppression des doublons</span>
    <span class="n">initial_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">initial_rows</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">initial_rows</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s2"> lignes dupliquées supprimées.&quot;</span><span class="p">)</span>

    <span class="c1"># Conversion de &#39;augementation_salaire_precedente&#39;</span>
    <span class="n">col_aug</span> <span class="o">=</span> <span class="s2">&quot;augementation_salaire_precedente&quot;</span>
    <span class="k">if</span> <span class="n">col_aug</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Conversion de la colonne &#39;</span><span class="si">{</span><span class="n">col_aug</span><span class="si">}</span><span class="s2">&#39; en numérique...&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="n">col_aug</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="n">col_aug</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; %&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="n">col_aug</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col_aug</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;coerce&quot;</span><span class="p">)</span>
        <span class="n">nan_count</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">col_aug</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nan_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nan_count</span><span class="si">}</span><span class="s2"> valeur(s) dans &#39;</span><span class="si">{</span><span class="n">col_aug</span><span class="si">}</span><span class="s2">&#39; n&#39;ont pas pu être converties &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;en numérique et sont devenue(s) NaN.&quot;</span>
            <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Colonne &#39;</span><span class="si">{</span><span class="n">col_aug</span><span class="si">}</span><span class="s2">&#39; convertie avec succès en type numérique.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;La colonne &#39;</span><span class="si">{</span><span class="n">col_aug</span><span class="si">}</span><span class="s2">&#39; n&#39;a pas été trouvée pour la conversion numérique.&quot;</span>
        <span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Nettoyage des données terminé.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>



<div class="viewcode-block" id="create_features">
<a class="viewcode-back" href="../../autoapi/data_processing/preprocess/index.html#data_processing.preprocess.create_features">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_features</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crée de nouvelles features (ingénierie des features) à partir des colonnes existantes.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): DataFrame d&#39;entrée (généralement après nettoyage et mappage binaire).</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: DataFrame avec les nouvelles features ajoutées.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Début de la création de features...&quot;</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># --- EXEMPLE DE FEATURE A AJOUTER ---</span>
    <span class="c1"># Si vous voulez ajouter une feature &#39;satisfaction_moyenne&#39; basée sur les colonnes Q_...</span>
    <span class="c1"># sondage_cols = [col for col in df.columns if col.startswith(&#39;Q_&#39;) and col not in [&#39;Q_satisfaction_generale&#39;]]</span>
    <span class="c1"># if sondage_cols:</span>
    <span class="c1">#     df[&#39;satisfaction_moyenne_autres_sondages&#39;] = df[sondage_cols].mean(axis=1, skipna=True)</span>
    <span class="c1">#     logger.info(&quot;Feature &#39;satisfaction_moyenne_autres_sondages&#39; créée.&quot;)</span>
    <span class="c1"># else:</span>
    <span class="c1">#     logger.info(&quot;Aucune colonne de sondage (Q_...) trouvée pour calculer &#39;satisfaction_moyenne_autres_sondages&#39;.&quot;)</span>

    <span class="c1"># Pour l&#39;instant, cette fonction ne fait rien de plus.</span>
    <span class="c1"># Vous pouvez ajouter ici la logique de création de features que vous aviez dans vos notebooks.</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Création de features terminée (actuellement, pas de nouvelles features implémentées).&quot;</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>



<div class="viewcode-block" id="build_preprocessor">
<a class="viewcode-back" href="../../autoapi/data_processing/preprocess/index.html#data_processing.preprocess.build_preprocessor">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_preprocessor</span><span class="p">(</span>
    <span class="n">numerical_cols</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">onehot_cols</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">ordinal_cols</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">ordinal_categories_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>  <span class="c1"># Renommé pour correspondre à l&#39;usage dans la fct</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ColumnTransformer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construit et retourne un objet ColumnTransformer de Scikit-learn pour le prétraitement.</span>

<span class="sd">    Le ColumnTransformer applique :</span>
<span class="sd">    - Imputation par la médiane puis StandardScaler aux colonnes numériques.</span>
<span class="sd">    - Imputation par la valeur la plus fréquente puis OneHotEncoder aux colonnes catégorielles nominales.</span>
<span class="sd">    - Imputation par la valeur la plus fréquente puis OrdinalEncoder aux colonnes catégorielles ordinales.</span>

<span class="sd">    Args:</span>
<span class="sd">        numerical_cols (list): Liste des noms des colonnes numériques.</span>
<span class="sd">        onehot_cols (list): Liste des noms des colonnes catégorielles à encoder en One-Hot.</span>
<span class="sd">        ordinal_cols (list): Liste des noms des colonnes catégorielles ordinales.</span>
<span class="sd">        ordinal_categories_map (dict): Dictionnaire spécifiant l&#39;ordre des catégories</span>
<span class="sd">                                     pour chaque colonne ordinale.</span>
<span class="sd">                                     Format: {&#39;nom_col_ord&#39;: [&#39;cat1&#39;, &#39;cat2&#39;, ...]}</span>

<span class="sd">    Returns:</span>
<span class="sd">        ColumnTransformer: Objet ColumnTransformer configuré mais non ajusté.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Si les catégories pour une colonne ordinale ne sont pas définies</span>
<span class="sd">                    dans `ordinal_categories_map`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Construction du préprocesseur Sklearn (ColumnTransformer)...&quot;</span><span class="p">)</span>
    <span class="n">transformers_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">numerical_cols</span><span class="p">:</span>
        <span class="n">numerical_transformer</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span>
            <span class="n">steps</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;imputer&quot;</span><span class="p">,</span> <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;scaler&quot;</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">transformers_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;num&quot;</span><span class="p">,</span> <span class="n">numerical_transformer</span><span class="p">,</span> <span class="n">numerical_cols</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Transformateur numérique configuré pour les colonnes : </span><span class="si">{</span><span class="n">numerical_cols</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">onehot_cols</span><span class="p">:</span>
        <span class="n">onehot_transformer</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span>
            <span class="n">steps</span><span class="o">=</span><span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;imputer&quot;</span><span class="p">,</span> <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;most_frequent&quot;</span><span class="p">)),</span>
                <span class="p">(</span>
                    <span class="s2">&quot;onehot&quot;</span><span class="p">,</span>
                    <span class="n">OneHotEncoder</span><span class="p">(</span>
                        <span class="n">handle_unknown</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">sparse_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="s2">&quot;first&quot;</span>
                    <span class="p">),</span>
                <span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">transformers_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;onehot&quot;</span><span class="p">,</span> <span class="n">onehot_transformer</span><span class="p">,</span> <span class="n">onehot_cols</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Transformateur OneHot configuré pour les colonnes : </span><span class="si">{</span><span class="n">onehot_cols</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">ordinal_cols</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">ordinal_cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ordinal_categories_map</span>
            <span class="p">):</span>  <span class="c1"># Utilisation de ordinal_categories_map</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Les catégories pour la colonne ordinale &#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#39; ne sont pas définies dans ordinal_categories_map.&quot;</span>
                <span class="p">)</span>
            <span class="n">categories_for_col</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">ordinal_categories_map</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
            <span class="p">]</span>  <span class="c1"># Utilisation de ordinal_categories_map</span>
            <span class="n">ordinal_transformer_col</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span>
                <span class="n">steps</span><span class="o">=</span><span class="p">[</span>
                    <span class="p">(</span><span class="s2">&quot;imputer&quot;</span><span class="p">,</span> <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;most_frequent&quot;</span><span class="p">)),</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;ordinal&quot;</span><span class="p">,</span>
                        <span class="n">OrdinalEncoder</span><span class="p">(</span>
                            <span class="n">categories</span><span class="o">=</span><span class="n">categories_for_col</span><span class="p">,</span>
                            <span class="n">handle_unknown</span><span class="o">=</span><span class="s2">&quot;use_encoded_value&quot;</span><span class="p">,</span>
                            <span class="n">unknown_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>  <span class="c1"># Utiliser np.nan, qui sera géré par l&#39;imputer numérique si la colonne devient numérique</span>
                            <span class="c1"># ou -1 si vous préférez et que l&#39;imputer numérique n&#39;est pas appliqué ensuite</span>
                        <span class="p">),</span>
                    <span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">transformers_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">f</span><span class="s2">&quot;ord_</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ordinal_transformer_col</span><span class="p">,</span> <span class="p">[</span><span class="n">col</span><span class="p">]))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Transformateurs ordinaux configurés pour les colonnes : </span><span class="si">{</span><span class="n">ordinal_cols</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">transformers_list</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Aucune colonne spécifiée pour le preprocessing. Le ColumnTransformer sera vide et utilisera remainder=&#39;passthrough&#39;.&quot;</span>
        <span class="p">)</span>
        <span class="c1"># Retourner un transformateur qui ne fait rien mais ne plante pas.</span>
        <span class="k">return</span> <span class="n">ColumnTransformer</span><span class="p">(</span><span class="n">transformers</span><span class="o">=</span><span class="p">[],</span> <span class="n">remainder</span><span class="o">=</span><span class="s2">&quot;passthrough&quot;</span><span class="p">)</span>

    <span class="n">preprocessor</span> <span class="o">=</span> <span class="n">ColumnTransformer</span><span class="p">(</span><span class="n">transformers</span><span class="o">=</span><span class="n">transformers_list</span><span class="p">,</span> <span class="n">remainder</span><span class="o">=</span><span class="s2">&quot;drop&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Préprocesseur Sklearn (ColumnTransformer) construit avec succès.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">preprocessor</span></div>



<div class="viewcode-block" id="run_preprocessing_pipeline">
<a class="viewcode-back" href="../../autoapi/data_processing/preprocess/index.html#data_processing.preprocess.run_preprocessing_pipeline">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">run_preprocessing_pipeline</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">binary_cols_map</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Doit venir de config.BINARY_FEATURES_MAPPING</span>
    <span class="n">ordinal_cols_categories_map</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Doit venir de config.ORDINAL_FEATURES_CATEGORIES. Renommé pour cohérence.</span>
    <span class="n">preprocessor</span><span class="p">:</span> <span class="n">ColumnTransformer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exécute le pipeline de preprocessing complet sur le DataFrame fourni.</span>

<span class="sd">    Orchestre les étapes de nettoyage, mappage binaire, création de features,</span>
<span class="sd">    et application (ajustement ou transformation) du ColumnTransformer.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): DataFrame d&#39;entrée brut.</span>
<span class="sd">        binary_cols_map (dict, optional): Mapping pour les features binaires.</span>
<span class="sd">                                          Utilise config.BINARY_FEATURES_MAPPING si non fourni (dans l&#39;appelant).</span>
<span class="sd">        ordinal_cols_categories_map (dict, optional): Catégories pour les features ordinales.</span>
<span class="sd">                                                Utilise config.ORDINAL_FEATURES_CATEGORIES si non fourni (dans l&#39;appelant).</span>
<span class="sd">        preprocessor (ColumnTransformer, optional): Un ColumnTransformer pré-ajusté.</span>
<span class="sd">                                                  Requis si `fit` est False.</span>
<span class="sd">        fit (bool, optional): Si True, le préprocesseur est ajusté (`fit_transform`) sur les données.</span>
<span class="sd">                              Si False, le `preprocessor` fourni est utilisé pour transformer (`transform`) les données.</span>
<span class="sd">                              Par défaut à False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple: Contenant selon le mode `fit`:</span>
<span class="sd">               Si `fit` est True: (X_processed_df, y_series, fitted_processor_instance)</span>
<span class="sd">               Si `fit` est False: (X_processed_df, y_series)</span>
<span class="sd">               Où X_processed_df est un DataFrame et y_series est une Series.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Si la colonne cible est manquante après les premières étapes,</span>
<span class="sd">                    ou si `fit` est False et aucun `preprocessor` n&#39;est fourni,</span>
<span class="sd">                    ou si une colonne ordinale spécifiée n&#39;existe pas dans le DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exécution du pipeline de preprocessing (fit=</span><span class="si">{</span><span class="n">fit</span><span class="si">}</span><span class="s2">)...&quot;</span><span class="p">)</span>
    <span class="n">df_clean</span> <span class="o">=</span> <span class="n">clean_data</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="c1"># Utiliser les mappings passés en argument, ou ceux de config si non fournis par l&#39;appelant</span>
    <span class="n">current_binary_map</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">binary_cols_map</span>
        <span class="k">if</span> <span class="n">binary_cols_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="n">config</span><span class="o">.</span><span class="n">BINARY_FEATURES_MAPPING</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">current_binary_map</span><span class="p">:</span>  <span class="c1"># Vérifier si le mapping est non vide/None</span>
        <span class="n">df_mapped</span> <span class="o">=</span> <span class="n">map_binary_features</span><span class="p">(</span><span class="n">df_clean</span><span class="p">,</span> <span class="n">current_binary_map</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df_mapped</span> <span class="o">=</span> <span class="n">df_clean</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># Pas de mappage binaire à faire</span>

    <span class="n">df_featured</span> <span class="o">=</span> <span class="n">create_features</span><span class="p">(</span><span class="n">df_mapped</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">TARGET_VARIABLE</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df_featured</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;La colonne cible &#39;</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">TARGET_VARIABLE</span><span class="si">}</span><span class="s2">&#39; n&#39;est pas présente après clean/map/feature.&quot;</span>
        <span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">df_featured</span><span class="p">[</span><span class="n">config</span><span class="o">.</span><span class="n">TARGET_VARIABLE</span><span class="p">]</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">df_featured</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">TARGET_VARIABLE</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Utiliser les catégories ordinales passées en argument, ou celles de config</span>
    <span class="n">current_ordinal_map</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">ordinal_cols_categories_map</span>
        <span class="k">if</span> <span class="n">ordinal_cols_categories_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="n">config</span><span class="o">.</span><span class="n">ORDINAL_FEATURES_CATEGORIES</span>
    <span class="p">)</span>
    <span class="n">ordinal_to_encode</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">current_ordinal_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="n">current_ordinal_map</span> <span class="k">else</span> <span class="p">[]</span>

    <span class="c1"># Identification des types de colonnes pour le ColumnTransformer</span>
    <span class="n">potential_numerical_cols</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">numerical_to_scale</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">potential_numerical_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ordinal_to_encode</span>
    <span class="p">]</span>
    <span class="c1"># Les colonnes binaires mappées en 0/1 sont numériques et seront scalées par défaut ici.</span>
    <span class="c1"># Si on veut les exclure du scaling, il faudrait les retirer de numerical_to_scale.</span>

    <span class="n">onehot_to_encode</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">col</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;object&quot;</span><span class="p">,</span> <span class="s2">&quot;category&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ordinal_to_encode</span>
    <span class="p">]</span>

    <span class="c1"># Vérifier que les colonnes ordinales existent bien dans X avant de les passer à build_preprocessor</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">ordinal_to_encode</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># Cela peut arriver si une colonne listée dans ORDINAL_FEATURES_CATEGORIES a été droppée</span>
            <span class="c1"># ou n&#39;était pas dans le df initial.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;La colonne ordinale &#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#39; spécifiée dans ordinal_cols_categories_map n&#39;existe pas dans le DataFrame X.&quot;</span>
            <span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Colonnes identifiées pour la mise à l&#39;échelle (numériques) : </span><span class="si">{</span><span class="n">numerical_to_scale</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Colonnes identifiées pour OneHotEncoding : </span><span class="si">{</span><span class="n">onehot_to_encode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Colonnes identifiées pour OrdinalEncoding : </span><span class="si">{</span><span class="n">ordinal_to_encode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fit</span><span class="p">:</span>
        <span class="c1"># Construire le préprocesseur avec les catégories ordinales actuelles</span>
        <span class="n">processor_instance</span> <span class="o">=</span> <span class="n">build_preprocessor</span><span class="p">(</span>
            <span class="n">numerical_to_scale</span><span class="p">,</span>
            <span class="n">onehot_to_encode</span><span class="p">,</span>
            <span class="n">ordinal_to_encode</span><span class="p">,</span>
            <span class="n">current_ordinal_map</span><span class="p">,</span>  <span class="c1"># Passer le dictionnaire complet</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Ajustement (fit) et transformation des données X...&quot;</span><span class="p">)</span>
        <span class="n">X_processed</span> <span class="o">=</span> <span class="n">processor_instance</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">feature_names</span> <span class="o">=</span> <span class="n">processor_instance</span><span class="o">.</span><span class="n">get_feature_names_out</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Impossible d&#39;obtenir les noms de features via get_feature_names_out(): </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Noms génériques utilisés.&quot;</span>
            <span class="p">)</span>
            <span class="n">feature_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;feature_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X_processed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transformation X terminée.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">X_processed</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">feature_names</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">index</span><span class="p">),</span>
            <span class="n">y</span><span class="p">,</span>
            <span class="n">processor_instance</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Mode transform uniquement</span>
        <span class="k">if</span> <span class="n">preprocessor</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Transformation des données X (sans ajustement) en utilisant le préprocesseur fourni...&quot;</span>
            <span class="p">)</span>
            <span class="n">X_processed</span> <span class="o">=</span> <span class="n">preprocessor</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">feature_names</span> <span class="o">=</span> <span class="n">preprocessor</span><span class="o">.</span><span class="n">get_feature_names_out</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Impossible d&#39;obtenir les noms de features via get_feature_names_out(): </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Noms génériques utilisés.&quot;</span>
                <span class="p">)</span>
                <span class="n">feature_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;feature_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X_processed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transformation X terminée.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">X_processed</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">feature_names</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Erreur: `fit` est False mais aucun `preprocessor` n&#39;a été fourni.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Un preprocessor doit être fourni si fit=False.&quot;</span><span class="p">)</span></div>



<span class="c1"># Bloc de test pour une exécution directe (poetry run python -m src.data_processing.preprocess)</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;--- Démarrage du test direct du module preprocess.py ---&quot;</span><span class="p">)</span>
    <span class="c1"># Importer load_and_merge_csvs ici pour éviter l&#39;import circulaire au niveau du module</span>
    <span class="c1"># si load_data devait importer qqch de preprocess (ce qui n&#39;est pas le cas actuellement)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">src.data_processing.load_data</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_and_merge_csvs</span>

<div class="viewcode-block" id="df_raw">
<a class="viewcode-back" href="../../autoapi/data_processing/preprocess/index.html#data_processing.preprocess.df_raw">[docs]</a>
        <span class="n">df_raw</span> <span class="o">=</span> <span class="n">load_and_merge_csvs</span><span class="p">()</span></div>


        <span class="k">if</span> <span class="n">df_raw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">df_raw</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Données brutes chargées pour le test: </span><span class="si">{</span><span class="n">df_raw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> lignes.&quot;</span>
            <span class="p">)</span>
            <span class="c1"># Test du pipeline de preprocessing complet en mode fit=True</span>
            <span class="c1"># Les mappings et catégories sont pris depuis config.py par défaut dans run_preprocessing_pipeline</span>
            <span class="n">X_p</span><span class="p">,</span> <span class="n">y_p</span><span class="p">,</span> <span class="n">proc</span> <span class="o">=</span> <span class="n">run_preprocessing_pipeline</span><span class="p">(</span>
                <span class="n">df_raw</span><span class="p">,</span>
                <span class="c1"># binary_cols_map et ordinal_cols_categories sont pris de config par défaut</span>
                <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Preprocessing Réussi (fit=True) ---&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape X_processed:&quot;</span><span class="p">,</span> <span class="n">X_p</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;X_processed (head):&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">X_p</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">y (head):&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">y_p</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Colonnes après preprocessing:&quot;</span><span class="p">,</span> <span class="n">X_p</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

            <span class="c1"># Exemple de test en mode transform=True avec le processeur fitté</span>
            <span class="c1"># On prend un échantillon des données brutes pour simuler de nouvelles données</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_raw</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">df_sample_for_transform</span> <span class="o">=</span> <span class="n">df_raw</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                    <span class="n">n</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_raw</span><span class="p">)),</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span>
                <span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Test du mode transform sur </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df_sample_for_transform</span><span class="p">)</span><span class="si">}</span><span class="s2"> échantillons...&quot;</span>
                <span class="p">)</span>
                <span class="n">X_t</span><span class="p">,</span> <span class="n">y_t</span> <span class="o">=</span> <span class="n">run_preprocessing_pipeline</span><span class="p">(</span>
                    <span class="n">df_sample_for_transform</span><span class="p">,</span>
                    <span class="n">preprocessor</span><span class="o">=</span><span class="n">proc</span><span class="p">,</span>  <span class="c1"># Utiliser le processeur fitté</span>
                    <span class="n">fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Preprocessing Réussi (fit=False) ---&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape X_transformed:&quot;</span><span class="p">,</span> <span class="n">X_t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;X_transformed (head):&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">X_t</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Impossible de charger les données brutes pour le test du module preprocess.&quot;</span>
            <span class="p">)</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e_main</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Erreur lors de l&#39;exécution du test de preprocess.py ---&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">e_main</span><span class="p">)</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">traceback</span>

        <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;--- Fin du test direct du module preprocess.py ---&quot;</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Droits d'auteur 2025, Cyrille ELIE.</p>
  </div>

  Compilé avec <a href="https://www.sphinx-doc.org/">Sphinx</a> en utilisant un
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">thème</a>
    fourni par <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>